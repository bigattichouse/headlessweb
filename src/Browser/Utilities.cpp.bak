#include "Browser.h"
#include <gtk/gtk.h>
#include <glib.h>
#include <iostream>
#include <filesystem>

// External debug flag
extern bool g_debug;

// ========== Wait Method ==========

void Browser::wait(int milliseconds) {
    if (milliseconds <= 0) return;
    
    struct TimeoutData {
        GMainLoop* loop;
        guint source_id;
        bool completed;
    };
    
    TimeoutData data = {main_loop, 0, false};
    
    data.source_id = g_timeout_add(milliseconds, [](gpointer user_data) -> gboolean {
        TimeoutData* data = static_cast<TimeoutData*>(user_data);
        data->completed = true;
        if (g_main_loop_is_running(data->loop)) {
            g_main_loop_quit(data->loop);
        }
        return G_SOURCE_REMOVE;
    }, &data);
    
    g_main_loop_run(main_loop);
    
    if (!data.completed && data.source_id != 0) {
        g_source_remove(data.source_id);
    }
}

// ========== Page State Validation ==========

bool Browser::isPageLoaded() const {
    std::string readyState = const_cast<Browser*>(this)->executeJavascriptSync(
        "(function() { try { return document.readyState; } catch(e) { return 'loading'; } })()");
    return readyState == "complete" || readyState == "interactive";
}

std::string Browser::getPageLoadState() const {
    return const_cast<Browser*>(this)->executeJavascriptSync(
        "(function() { try { return document.readyState + '|' + window.location.href; } catch(e) { return 'error|unknown'; } })()");
}

// ========== Page Source ==========

std::string Browser::getPageSource() {
    std::string js = R"(
        (function() {
            try {
                return document.documentElement.outerHTML;
            } catch(e) {
                return '';
            }
        })()
    )";
    
    return executeJavascriptSync(js);
}

// ========== Scroll Position Management ==========

void Browser::setScrollPosition(int x, int y) {
    std::string js = "window.scrollTo(" + std::to_string(x) + ", " + std::to_string(y) + "); 'scrolled';";
    executeJavascriptSync(js);
}

std::pair<int, int> Browser::getScrollPosition() {
    std::string js = R"(
        (function() {
            const x = window.pageXOffset || document.documentElement.scrollLeft || 0;
            const y = window.pageYOffset || document.documentElement.scrollTop || 0;
            return x + ',' + y;
        })()
    )";
    
    std::string result = executeJavascriptSync(js);
    
    // Parse the result
    int x = 0, y = 0;
    size_t comma = result.find(',');
    if (comma != std::string::npos) {
        try {
            x = std::stoi(result.substr(0, comma));
            y = std::stoi(result.substr(comma + 1));
        } catch (...) {
            // Keep defaults
        }
    }
    
    return std::make_pair(x, y);
}

// ========== Action Sequence Execution ==========

bool Browser::executeActionSequence(const std::vector<Session::RecordedAction>& actions) {
    debug_output("Executing action sequence with " + std::to_string(actions.size()) + " actions");
    
    for (size_t i = 0; i < actions.size(); i++) {
        const auto& action = actions[i];
        debug_output("  Action " + std::to_string(i + 1) + ": " + action.type + " on " + action.selector);
        
        bool success = false;
        
        if (action.type == "click") {
            success = clickElement(action.selector);
        } else if (action.type == "type" || action.type == "fill") {
            success = fillInput(action.selector, action.value);
        } else if (action.type == "select") {
            success = selectOption(action.selector, action.value);
        } else if (action.type == "check") {
            success = checkElement(action.selector);
        } else if (action.type == "uncheck") {
            success = uncheckElement(action.selector);
        } else if (action.type == "focus") {
            success = focusElement(action.selector);
        } else if (action.type == "submit") {
            success = submitForm(action.selector);
        } else if (action.type == "navigate") {
            loadUri(action.value);
            success = waitForNavigationEvent(10000);
        } else if (action.type == "wait") {
            try {
                int delay = std::stoi(action.value);
                wait(delay);
                success = true;
            } catch (...) {
                success = false;
            }
        } else {
            std::cerr << "Unknown action type: " << action.type << std::endl;
            success = false;
        }
        
        if (!success) {
            std::cerr << "Action failed: " << action.type << " on " << action.selector << std::endl;
            return false;
        }
        
        // Apply delay after action
        if (action.delay > 0) {
            wait(action.delay);
        } else {
            // Default small delay between actions
            wait(100);
        }
    }
    
    debug_output("Action sequence completed successfully");
    return true;
}

// ========== Data Manager Initialization ==========

void Browser::initializeDataManager(const std::string& sessionName) {
    // Create session-specific data directory
    std::string sessionDir = sessionDataPath + "/" + sessionName;
    std::filesystem::create_directories(sessionDir);
    
    // Update cookie storage location for this session
    if (cookieManager) {
        std::string cookieFile = sessionDir + "/cookies.txt";
        // webkit_cookie_manager_set_persistent_storage(cookieManager, 
            // cookieFile.c_str(), WEBKIT_COOKIE_PERSISTENT_STORAGE_TEXT);
        
        debug_output("Initialized data manager for session: " + sessionName);
    }
}
